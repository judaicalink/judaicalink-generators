// Generated by CoffeeScript 1.7.1
(function() {
  var Crawler, cheerio, fs, gitdir, githash, gitref, http, path;

  http = require('http');

  cheerio = require('cheerio');

  fs = require('fs');

  path = require('path');

  Crawler = (function() {
    function Crawler(processPage, markVisited) {
      this.processPage = processPage;
      this.markVisited = markVisited;
      this.visited = {};
      this.counter = 0;
      this.running = 0;
      this.queued = 0;
      this.queue = [];
      this.records = [];
      this.running = 0;
      this.lastRequest = 0;
      this.githash = githash();
      this.outfile = "output.json";
      this.errorfile = "error.txt";
      this.prepareURL = function(url) {
        return url;
      };
      if (this.markVisited === void 0) {
        this.markVisited = function(visited, record) {
          return visited[record.uri] = "";
        };
      }
      this.maxSockets = 5;
      this.requestDelay = 1000;
      http.globalAgent.maxSockets = this.maxSockets;
    }

    Crawler.prototype.restart = function(seed) {
      var error, error2, l, output, r, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.seed = seed;
      try {
        output = fs.readFileSync(this.outfile);
        this.records = JSON.parse(output);
      } catch (_error) {
        error = _error;
        if (error.code !== "ENOENT") {
          try {
            this.records = JSON.parse(output + "]");
          } catch (_error) {
            error2 = _error;
            console.log(error2.message);
            return;
          }
        }
      }
      this.counter = this.records.length;
      _ref = this.records;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        this.markVisited(this.visited, r);
      }
      _ref1 = this.records;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        r = _ref1[_j];
        if (r.links) {
          _ref2 = r.links;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            l = _ref2[_k];
            this.checkForQueue(l.href);
          }
        }
      }
      console.log("Queued URLs: " + this.queued);
      console.log("Records loaded: " + this.records.length);
      console.log("Visited: " + (Object.keys(this.visited).length));
      if (this.counter === 0) {
        fs.writeFile(this.outfile, "[\n");
      }
      this.checkForQueue(this.seed);
      return console.log(new Date());
    };

    Crawler.prototype.checkForQueue = function(url) {
      url = this.prepareURL(url);
      if (this.visited[url] === void 0 && this.queue.indexOf(url) < 0) {
        this.queue.push(url);
        console.log("Queued: " + url + " (Queue size: " + this.queue.length + ")");
        this.queued++;
        this.processQueue();
      }
    };

    Crawler.prototype.request = function(url, callback, redirect) {
      var doRequest;
      if (redirect === void 0) {
        this.running++;
        redirect = url;
      }
      doRequest = (function(_this) {
        return function() {
          var now, req;
          now = new Date().getTime();
          if (now - _this.lastRequest < _this.requestDelay) {
            setTimeout(doRequest, now - _this.lastRequest);
            return;
          }
          console.log("Request: " + now + " (" + (now - _this.lastRequest) + ")");
          _this.lastRequest = now;
          req = http.get(redirect, function(res) {
            var e, html;
            console.log("Resonse: " + res.statusCode + " (" + (new Date().getTime() - now) + " ms)");
            if (res.statusCode >= 300 && res.statusCode < 307) {
              _this.request(url, callback, res.headers["location"]);
              res.on("data", function() {});
              return;
            }
            if (res.statusCode !== 200) {
              e = new Error("Server Error: " + res.statusCode + ", URL: " + url + ", Requested: " + redirect);
              e.url = url;
              res.redirect = redirect;
              callback(e);
              res.on("data", function() {});
              _this.requestComplete();
              return;
            }
            html = "";
            res.on("data", function(chunk) {
              return html += chunk;
            });
            return res.on("end", function() {
              var record;
              if (res.data === void 0) {
                res.data = html;
              }
              res.url = url;
              res.redirect = redirect;
              record = callback(null, res, cheerio.load(html));
              if (record !== null) {
                record.created = new Date().toISOString();
                record.githash = _this.githash;
                _this.records.push(record);
                fs.appendFile(_this.outfile, (_this.counter++ > 0 ? ",\n" : "") + JSON.stringify(record, null, 1));
                _this.markVisited(_this.visited, record);
                console.log("" + _this.counter + ". Processed " + record.uri + " (id=" + record.id + ") (R/Q/Q=" + _this.running + "/" + _this.queued + "/" + _this.queue.length + ") (" + (new Date().getTime() - now) + " ms)");
              }
              return _this.requestComplete();
            });
          });
          return req.on("error", function(e) {
            e.url = url;
            callback(e);
            return _this.requestComplete();
          });
        };
      })(this);
      return doRequest();
    };

    Crawler.prototype.requestComplete = function() {
      this.running--;
      this.queued--;
      if (this.running === 0) {
        return this.processQueue();
      }
    };

    Crawler.prototype.processQueue = function() {
      var q, toProcess, _i, _len;
      if (this.queue.length === 0 && this.running === 0) {
        this.finish();
        return;
      }
      if (this.running < this.maxSockets) {
        toProcess = this.queue.splice(0, this.maxSockets);
        for (_i = 0, _len = toProcess.length; _i < _len; _i++) {
          q = toProcess[_i];
          this.request(q, this.processPage);
        }
      }
    };

    Crawler.prototype.finish = function() {
      fs.appendFile(this.outfile, "]\n");
      return console.log("Finished: " + new Date());
    };

    return Crawler;

  })();

  gitdir = function() {
    return path.join(require("parentpath").sync(".git"), ".git");
  };

  gitref = function() {
    return fs.readFileSync(path.join(gitdir(), "HEAD"), "utf8").replace("ref: ", "").trim();
  };

  githash = function() {
    return fs.readFileSync(path.join(gitdir(), gitref()), "utf8").trim();
  };

  module.exports = Crawler;

}).call(this);
